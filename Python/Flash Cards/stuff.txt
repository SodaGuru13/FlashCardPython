derive(excs)
Returns an exception group with the same message, but which wraps the exceptions in excs. This method is used by subgroup() and split(). A subclass needs to override it in order to make subgroup() and split() return instances of the subclass rather than ExceptionGroup. subgroup() and split() copy the __traceback__, __cause__, __context__ and __notes__ fields from the original exception group to the one returned by derive(), so these fields do not need to be updated by derive(). class MyGroup(ExceptionGroup): def derive(self, excs): return MyGroup(self.message, excs), e = MyGroup("eg", [ValueError(1), TypeError(2)]), e.add_note("a note"), e.__context__ = Exception("context"), e.__cause__ = Exception("cause"), try: raise e, except Exception as e: exc = e, match, rest = exc.split(ValueError), exc, exc.__context__, exc.__cause__, exc.__notes__ -> (MyGroup('eg', [ValueError(1), TypeError(2)]), Exception('context'), Exception('cause'), ['a note']), match, match.__context__, match.__cause__, match.__notes__ -> (MyGroup('eg', [ValueError(1)]), Exception('context'), Exception('cause'), ['a note']), rest, rest.__context__, rest.__cause__, rest.__notes__ -> (MyGroup('eg', [TypeError(2)]), Exception('context'), Exception('cause'), ['a note']), exc.__traceback__ is match.__traceback__ is rest.__traceback__ -> True. Note that BaseExceptionGroup defines __new__(), so subclasses that need a different constructor signature need to override that rather than __init__(). For example, the following defines an exception group subclass which accepts an exit_code and and constructs the groupâ€™s message from it. class Errors(ExceptionGroup): def __new__(cls, errors, exit_code): self = super().__new__(Errors, f"exit code: {exit_code}", errors), self.exit_code = exit_code, return self, def derive(self, excs): return Errors(excs, self.exit_code). Like ExceptionGroup, any subclass of BaseExceptionGroup which is also a subclass of Exception can only wrap instances of Exception.